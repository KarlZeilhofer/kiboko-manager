#include "displayrenderer.h"
#include "mainwindow.h"
#include "competition.h"
#include <QPainter>
#include <QImage>
#include "packet.h"
#include "crc8.h"

DisplayRenderer::DisplayRenderer(DisplayPreviewWidget *widget1, DisplayPreviewWidget *widget2,
                                 DialogDisplaySettings *settings, QObject *parent) :
    QObject(parent)
{
    this->widget1 = widget1;
    this->widget2 = widget2;
    this->settingsDialog = settings;
}

void DisplayRenderer::render(RunData *runData, bool realDisplayData)
{
    this->runData = runData;

    QImage im(widget1->getDotSize().width(), widget1->getDotSize().height(), QImage::Format_Mono);
	im.fill(0);
    QPainter p(&im);
    p.setPen(QColor(Qt::white));
    p.setRenderHint(QPainter::TextAntialiasing, false);

	// render display 1
    int ySum=0;
    for(int n=1; n<=3; n++)
	{
        QFont font = settingsDialog->getFont(n);
        font.setStyleStrategy(QFont::NoAntialias);
        p.setFont(font);
        int y = settingsDialog->getFont(n).pointSize();
        ySum+=y;
        p.drawText(0, ySum-settingsDialog->getOffset(n), buildString(settingsDialog->getFormat(n)));
        ySum-=settingsDialog->getOffset(n);
    }
    widget1->setImage(im);
	
	QImage im1(im);		// save a copy of image 1

	// render display 2
    im.fill(0);
    ySum=0;
    for(int n=4; n<=6; n++)
	{
        QFont font = settingsDialog->getFont(n);
        font.setStyleStrategy(QFont::NoAntialias);
        p.setFont(font);
        int y = font.pointSize();
        ySum+=y;
        p.drawText(0, ySum-settingsDialog->getOffset(n), buildString(settingsDialog->getFormat(n)));
        ySum-=settingsDialog->getOffset(n);
    }
    widget2->setImage(im);
	
	if(realDisplayData && settingsDialog->getEnabled())
	{
		sendDisplayData(im1, im);
	}
}

QString DisplayRenderer::buildString(QString format)
{
    format.replace("%d", QString::number(runData->getRound()));
    format.replace("%c", runData->getColor());
    format.replace("%b", QString::number(runData->getID()));
    format.replace("%z", QString::number(runData->getBoatID()));

    if(runData->getStartTimeID() >0){ // if valid time
        QTime runTime = MainWindow::competition()->getRunTime(runData->getID());
        format.replace("%t", MainWindow::convertTimeToString(runTime));
    }else{ // else dummy-time (used for testing the format strings in the display-settings-dialog)
        format.replace("%t", "12:34.56");
    }

    if(runData->getDSQ()){
        format.replace("%q", "DSQ");
    }else{
        format.replace("%q", "   ");
    }

    format.replace("%v", runData->getFirstName1());
    format.replace("%n", runData->getLastName1());
    format.replace("%V", runData->getFirstName2());
    format.replace("%N", runData->getLastName2());
	format.replace("%a", runData->getFirstName1().left(1));
	format.replace("%A", runData->getFirstName2().left(1));

    format.replace("%f", runData->getFireBrigade());

    return format;
}

// Display Data is written to data!
void DisplayRenderer::genMatrixData(QImage im, int displayNumber, uint8_t *data)
{
	/*
	 * the MATRIX display is made of modules with 7 columns each.
	 * each module has 28 lines and is accessed line by line.
	 * every line is represented as 1 byte (MSB is not used and should be 0)
	 * so the transmitted data is:
	 * for every module
	 *     for every line
	 *         one byte
	 */
	int datacounter=0;
    uint8_t headerImage[MATRIX_MODULES][MATRIX_ROWS];		// for header file export
	for(int mod=0; mod<MATRIX_MODULES; mod++)
	{
		for(int row=0; row<MATRIX_ROWS; row++)
		{
			uint8_t byte=0;
			for(int subcolumn=0; subcolumn<MATRIX_COLS_PER_MOD; subcolumn++)
			{
				int column=mod*MATRIX_COLS_PER_MOD+subcolumn;
				byte<<=1;
				
				// get b/w value for every pixel
				if(settingsDialog->getFlipDisplay(displayNumber))
				{
					// rotate by 180 deg
					byte |= im.pixel((MATRIX_MODULES*MATRIX_COLS_PER_MOD)-column-1, MATRIX_ROWS-row-1) & 1;
				}
				else
				{
					// normal
					byte |= im.pixel(column, row) & 1;
				}
			}
			data[datacounter]=byte;
			datacounter++;
			
            headerImage[mod][row]=byte;
		}
	}
	

	// export header file for display controller
	QFile file("image.h");
	if(!file.open(QFile::WriteOnly | QFile::Text))
	{
		return;
	}
	
	QTextStream str(&file);
	
	str<<"// generated by Kiboko-Manager at: "<<QDateTime::currentDateTime().toString()<<"\n";
	str<<"uint8_t image[MATRIX_MODULES][MATRIX_ROWS]=\n";
	str<<"{\n";
	for(int mod=0; mod<MATRIX_MODULES; mod++)
	{
		str<<"\t{";
		for(int row=0; row<MATRIX_ROWS; row++)
		{
			str<<"0x"<<QString::number(headerImage[mod][row], 16);
			if(row==MATRIX_ROWS-1)	// skip the ',' at the end
			{
				break;
			}
			str<<", ";
		}
		str<<"}";
		
		if(mod==MATRIX_MODULES-1)	// skip the ',' at the end
		{
			break;
		}
		str<<",\n";
	}
	str<<"\n};\n";
	
	file.close();
	

}

void DisplayRenderer::sendDisplayData(QImage im1, QImage im2)
{
	qDebug() << "sending data for displays";
	
	PC2TB_PACKET outPacket;

	// pack tha packet:
	outPacket.magicNumber1 = MAGIC_NUMBER1;
	outPacket.magicNumber2 = MAGIC_NUMBER2;
	outPacket.packetVersion = PACKET_VERSION;
	QTime midnight(0,0);
    int time_ms = midnight.msecsTo(MainWindow::app()->getTimeBaseTime());
	uint32_t time_100us = 10*time_ms;
	outPacket.pcTime_100us = time_100us;
	
	// ALGE text
	memcpy(outPacket.algeText, algeText().toAscii().data(), ALGE_TEXT_LEN);
	
	genMatrixData(im1, 1, outPacket.matrixData1);
	genMatrixData(im2, 2, outPacket.matrixData2);
	
	outPacket.matrixDataValid=1;
	
	outPacket.cmdReceiver=COMMAND_INVALID_RECEIVER;
	outPacket.command=COMMAND_INVALID_CMD;
	
	outPacket.crc = CRC8_run((uint8_t*)(&outPacket), (uint16_t)(sizeof(PC2TB_PACKET)-1));

	QByteArray datagram;
	datagram.setRawData((char*)(&outPacket), sizeof(PC2TB_PACKET));
	
	emit sendDatagram(datagram);
}

QString DisplayRenderer::algeText()
{
	Competition* comp=MainWindow::competition();
	QTime time=comp->getRunTime(runData->getID());
	
	// text for ALGE display
	QString timeText;
	if(time.isValid())
	{
		//                      DEFGHIJKL
		timeText=time.toString("mm:ss.zzz");
	}
	else
	{
		//        DEFGHIJKL
		timeText="  :  .   ";
	}
	
	QChar dsqChar;
	if(runData->getDSQ())
	{
		dsqChar='F';
	}
	else
	{
		dsqChar=' ';
	}
	
	//                     123456789ABC            MNO
	QString textA=QString("A          :"+timeText+"  \r");
	//                     123456789ABCDEFGHIJKL MNO
	QString textB=QString("B          :%1:%2.  %3  \r").arg(runData->getRound(), 2).arg(runData->getBoatID(), 2).arg(dsqChar);
	
	return textA+textB;
}
